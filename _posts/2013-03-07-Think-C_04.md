---
layout: post
title: "第四章 条件语句和递归"
date: 2013-03-07 14:39
---

#第四章 条件语句和递归

##4.1 条件语句的执行

为了写实用的程序，我们总是需要检查某些条件，然后根据检查的结果修改程序的行为。**条件语句(conditional statements)** 为我们提供了这种功能。最简单的形式是 if 语句：

	if(x > 0)
	{
		printf("x is positive\n");
	}

圆括号里的表达式就叫做条件。如果条件为真，花括号里的语句就会执行。如果条件为假，什么都不会发生。

条件可以包含任何 **比较运算符**：

	x == y          /* x 等于 y */
	x != y          /* x 不等于 y */
	x > y           /* x 大于 y */
	x < y           /* x 小于 y */
	x >= y          /* x 大于等于 y */
	x <= y          /* x 小于等于 y */

尽管你可能很熟悉这些操作，但是 C 语言的语法和数学符号还是有一点不同。常见的错误是用一个等号 **=** 代替两个等号 **==**。要记住，**=** 是赋值运算符，**==** 是比较运算符。另外，**=<** 和 **=>** 是不存在的。

比较运算符的两边必须是相同的类型。int 只能和 int 比较，double 只能和 double 比较。不幸的是，不能用这种方法比较字符串！比较字符串的方法我们会在另一章专门介绍。

##4.2 取摸运算符

取模运算符对整数（和整数表达式）进行操作，然后产生第一个数除以第二个数的余数。C 语言中的取模运算符是一个百分号 % 。语法和其他运算符一样：

	int quotient = 7 / 3;
	int remainder = 7 % 3;

第一个运算符，整数除法，结果是 2 。第二个运算符得到 1 。因此，7 除以 3 得 2，余数是 1 。

取模运算符的作用很神奇。例如，可以用来检查一个数是否可以被另一个数整除：如果 x % y 等于 0， x 就可以被 y 整除。

你还可以用取模运算符获取一个整数最右边的一位或几位数字。例如，x % 10 可以得到 x 最右边一位数字。类似的，x % 100 得到最右边的两位数。

##4.3 选择执行

条件语句的第二种形式是选择执行，这种情况下有两种可能性，条件的结果决定了哪一种会得到执行。语法类似：

	if(x%2 == 0)
	{
		printf("x is even\n");
	}
	else
	{
		printf("x is odd\n");
	}

如果 x 除以 2 的余数是零，x 就是偶数，这段代码会打印一个说明信息。如果条件是假的，就会执行第二套语句。因为条件只能是真或假，所以一定会选择一个执行。

另外，如果你觉得可能要经常检查数字的奇偶性，应该将这段代码放在一个函数里，例如：

	void PrintParity(int x)
	{
		if( x%2 == 0 )
		{
			printf("x is even \n");
		}
		else
		{
			printf("x is odd \n");
		}
	}

现在，你有了一个 **PrintParity** 函数，可以显示你所关心的任何整数的相应信息。在 main 函数里调用这个函数：

	PrintParity(17);

要记住，调用一个函数时，不要声明参数值的类型。C 语言可以识别它们的类型。千万别写成这样：

	int number = 17;
	PrintParity(int number);   /* WRONG!!! */

##4.4 条件语句链

有时想要检查多个相关联的条件，然后选择一个或几个执行。解决这个问题的一种方法是用链接多个 if 和 else ：

	if(x>0)
	{
		printf("x is positive\n");
	}
	else if(x < 0)
	{
		printf("x is negative\n");
	}
	else 
	{
		printf("x is zero\n");
	}

可以根据需要设置条件链的长度，可是条件太多可能会难以阅读。一种增加可读性的方法是使用标准的缩进，就像这些例子。如果将语句和括号按行排开，就会减少出错的概率，寻找错误也会很快。

##4.5 嵌套条件语句

条件语句除了可以链接，还可以嵌套。上面的例子还可以这样写：

	if(x == 0)
	{
		print("x is zero\n");
	}
	else
	{
		if(x > 0)
		{
			printf("x is positive\n");
		}
		else
		{
			printf("x is negative\n");
		}
	}

外层的条件语句包含了两个分支。第一个分支包含一个简单的输出语句，但是第二个分支包含了另一个 if 语句，它也有两个分支。辛运的是，那两个分支都是输出语句，尽管它们也是条件语句。

再次注意，缩进可以帮助我们理清代码的结构，但是嵌套的条件语句还是很难读。通常，要尽量避免使用它。

另一方面，这种 **嵌套结构** 是很常用的，以后还会见到，所以你最好掌握它。

## 4.6 return 语句

return 语句可以让我们提前结束函数的执行。当我们发现一个错误情况时，可以用它结束函数：

	void printLogarithm(double x)
	{
		if(x <= 0.0)
		{
			printf("Positive number only, please.\n");
			return;
		}

		double result = log(x);
		printf("The log of x is %f\n", result);
	}

这里定义了一个名叫 PrintLogarithm 的函数，带一个 double 型参数 x 。首先要检查 x 是否小于等于 0 ，如果条件为真，就显示一个错误信息，然后用 return 结束函数。执行流立即返回到调用者，该函数的剩余部分也不会执行了。

我在条件的右边用了一个浮点数，因为左边的 x 是一个浮点数。

记住，任何时候想要用数学函数库中的函数，一定要包含头文件 math.h 。

##4.7 递归

我在上一章说过，在一个函数中调用另一个函数是合法的，而且已经看到了几个例子。其实，一个函数调用它自己也是合法的。这样做的好处并不明显，但是它可以让程序变得非常神奇和有趣。

例如，看下面这个函数：

	void Countdown(int n)
	{
		if(n == 0)
		{
			printf("Blastoff!");
		}
		else
		{
			printf("%i",n);
			Countdown(n-1);
		}
	}

这个程序名叫 **Countdown**，带了一个整型参数。如果参数值为 0 ，就会输出 “Blastoff”，否则，会输出参数值，并用 **n-1** 作为参数再次调用 **Countdown**。

如果我们这样调用函数会发生什么：

	int main(void)
	{
		Countdown(3);
	}

Countdown 以 n=3 开始执行，因为 n 不等于 0，会输出 3，然后调用它自己 ...

—— Countdown 以 n=2 开始执行，因为 n 不等于 0，会输出 2，然后调用它自己 ...

———— Countdown 以 n=1 开始执行，因为 n 不等于 0，会输出 1，然后调用它自己 ...

—————— Countdown 以 n=0 开始执行，因为 n 等于 0，会输出 “Blastoff!”，然后返回 ...

———— Countdown 得到 n=1 的返回。

—— Countdown 得到 n=2 的返回。

Countdown 得到 n=3 的返回。

最后返回到 main 函数。所以，看到的输出如下：

	3
	2
	1
	Blastoff!

第二个例子让我们回顾一下 PrintNewLine 和 PrintThreeLines 函数。

	void PrintNewLine()
	{
		printf("\n");
	}

	void PrintThreeLines()
	{
		PrintNewLine(); PrintNewLine(); PrintNewLine();
	}

如果你想输出 106 个换行，上面这种方式就没什么用。一种更好的方法是：

	void PrintLines(int n)
	{
		if(n > 0)
		{
			printf("\n");
			PrintLines(n-1);
		}
	}

这个程序类似 Countdown；只要 n 大于 0，它就会输出一个换行，然后掉用自己输出剩下的 n-1 个换行。因此，换行的总数是 1+(n-1)，大约就是 n 。

一个函数调用它自己的过程叫做 **递归(recursion)**，这样的函数叫做 **递归的(recursive)** 。

##4.8 无限递归

在上一节的例子中，函数每次递归调用时，参数都会减少 1 ，所以最终它会变为 0 。参数等于 0 时，函数会立即返回，不再做任何递归调用。这种情况 —— 函数无需递归调用就可以完成 —— 叫做 **递归基(base case)** 。

如果一个递归永远无法到达递归基，它将永远递归的调用下去，程序永远不会结束。这叫做 **无限递归(infinite recursion)** ，通常这不是什么好事情。

在大多数编程环境中，带有无限递归的程序不会真的永远运行下去，最终总会被某些事情打断并且报告一个错误。这是我们见到的第一个运行时错误实例（只有在运行时才出现的错误）。

你可以写一个无限递归的小程序，然后运行它，看看会发生什么。

##4.9 递归函数的堆栈图

上一章我们曾经用一个堆栈图演示程序调用函数时的状态。用同样的图可以让我们更容易理解递归函数。

每当一个函数被调用时，就会新建一个包含函数局部变量和参数的实例。

下面是 Countdown 的堆栈图，调用时 n = 3 ：

![4-1](http://imgout.ph.126.net/14516023/4-1.jpg)

这里有一个 main 的实例和四个 Countdown 的实例，每个实例中参数 n 都是不同的值。在栈的底部，n=0 的 Countdown 是递归基。它不会再产生递归调用，所以就不再有 Countdown 的实例。

main 的实例是空的，因为 main 没有任何参数和局部变量。做一个练习，为 PrintLines 画一个堆栈图，参数 n=4 。

##4.10 词汇

**modulus(取摸):** 用于整数的运算符，产生两个数相除的余数。C 语言中用一个百分号 ( % ) 表示。

**conditional(条件语句):** 一组语句块，根据某些条件决定是否执行。

**chaining(链接):** 连接多个条件语句的一种方法。

**nesting(嵌套):** 将一个条件语句放入另一个条件语句的一个或两个分支中。

**recursion(递归):** 调用你目前正在执行的函数的过程。

**infinite recursion(无限递归):** 一种递归调用自身的函数，但是永远不会到达递归基。最终会导致一个运行时错误。

##4.11 练习

本节是德语，o(╯□╰)o


##笔记

* recursion ：递归
* condition ：条件，状况
* certain ：某些，的确，必然的
* certainly ：当然，一定
* parentheses ：括号，括弧
* brackets ：括号，括弧
* compare ：比较
* fortunately ：辛运的是
* unfortunately ：不幸的是
* yield ：产生
* digit ：数字
* division ：除法
* divided ：除，分
* remainder ：剩余，余数
* even ：偶数
* odd ：奇数
* parity ：奇偶性
* immediately ：立即
* obvious ：明显的
* infinite ：无限的
* without doing ：不做，没做
* Eventually ：最终
* instance ：实例，实体
* invoke ：呼吁，呼叫，调用